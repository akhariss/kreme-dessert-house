# Dokumentasi Database (SQL Schema) Kreme Dessert House

Dokumen ini berisi detail skema database PostgreSQL yang digunakan di Supabase, relasi antar tabel, dan kegunaan masing-masing tabel dalam aplikasi.

---

## 1. Schema Tables (ERD)

### A. Tabel Utama: `products`

Menyimpan data dasar produk.

```sql
CREATE TABLE products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('macaron', 'cake', 'gift box', 'pastry')),
  is_available BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);
```

- **Penggunaan**: Ditampilkan di Home Screen (List Produk).

### B. Tabel Detail: `prices`

Memisahkan harga dari produk (memungkinkan multiple currency di masa depan, meski sekarang default USD).

```sql
CREATE TABLE prices (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id BIGINT REFERENCES products(id) ON DELETE CASCADE,
  price DECIMAL(10,2) NOT NULL,
  currency TEXT DEFAULT 'USD',
  UNIQUE(product_id, currency) -- Satu produk hanya punya 1 harga per mata uang
);
```

- **Relasi**: `One-to-One` (secara logika aplikasi saat ini) ke `products`.
- **Penggunaan**: Ditampilkan di bawah nama produk di semua layar.

### C. Tabel Asset: `product_images`

Menyimpan URL gambar produk.

```sql
CREATE TABLE product_images (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id BIGINT REFERENCES products(id) ON DELETE CASCADE,
  image_url TEXT NOT NULL
);
```

- **Relasi**: `One-to-Many` (Satu produk bisa punya banyak gambar, tapi di app saat ini kita ambil gambar pertama saja).
- **Penggunaan**: Image component di Product Card & Detail.

### D. Tabel Informasi: `product_details`

Menyimpan detail tekstual panjang (Resep, Alergi, Cara Simpan).

```sql
CREATE TABLE product_details (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id BIGINT REFERENCES products(id) ON DELETE CASCADE,
  ingredients TEXT,
  allergen_information TEXT,
  storage_care TEXT
);
```

- **Relasi**: `One-to-One` ke `products`.
- **Penggunaan**: Hanya ditampilkan di halaman `DetailScreen`.

### E. Tabel User: `users`

Menyimpan data user hasil sync dari Clerk.

```sql
CREATE TABLE users (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY, -- Internal Supabase ID
  clerk_user_id TEXT UNIQUE NOT NULL,             -- ID dari Clerk
  email TEXT,
  full_name TEXT,
  avatar_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);
```

- **Fungsi**: Sebagai referensi Foreign Key untuk tabel Cart.

### F. Tabel Transaksi: `cart`

Keranjang belanja user.

```sql
CREATE TABLE cart (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE, -- User siapa?
  product_id BIGINT REFERENCES products(id) ON DELETE CASCADE, -- Beli apa?
  quantity INTEGER DEFAULT 1 CHECK (quantity > 0),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  UNIQUE(user_id, product_id) -- Mencegah duplikat baris untuk produk yang sama
);
```

- **Constraint**: `UNIQUE(user_id, product_id)` memastikan kalau user beli barang yang sama lagi, kita lakukan UPDATE quantity, bukan INSERT baris baru.

---

## 2. Relasi & Alur Data (Flow Maps)

### Alur Penghapusan Produk (Cascade Delete)

Karena kita menggunakan `ON DELETE CASCADE` pada Foreign Key:

1.  Admin menghapus Produk A dari tabel `products`.
2.  PostgreSQL otomatis menghapus:
    - Harga Produk A di tabel `prices`.
    - Gambar Produk A di tabel `product_images`.
    - Detail Produk A di tabel `product_details`.
    - Semua item di Keranjang user (`cart`) yang berisi Produk A.

- **Manfaat**: Database tidak pernah memiliki "data yatim piatu" (orphan records).

### Alur User Baru (Sync Flow)

1.  User Register di Clerk.
2.  App Login -> Cek tabel `users` berdasarkan `clerk_user_id`.
3.  Jika null -> INSERT ke `users`.
4.  User mulai belanja -> INSERT ke `cart` menggunakan UUID dari tabel `users` (bukan ID Clerk).

---

## 3. Database Functions & Views (Opsional tapi Recommended)

Aplikasi ini melakukan join manual di kode Javascript (backend service), namun query SQL aslinya terlihat seperti ini jika dijalankan manual:

**Query: Get All Products (Logic di `productService.getAllProducts`)**

```sql
SELECT
  p.id, p.name, p.category,
  pr.price,
  pi.image_url
FROM products p
LEFT JOIN prices pr ON p.id = pr.product_id
LEFT JOIN product_images pi ON p.id = pi.product_id
WHERE p.is_available = true;
```

**Query: Get Cart User (Logic di `cartService.fetchCart`)**

```sql
SELECT
  c.quantity,
  p.name,
  pr.price,
  pi.image_url
FROM cart c
JOIN products p ON c.product_id = p.id
JOIN prices pr ON p.id = pr.product_id
JOIN product_images pi ON p.id = pi.product_id
WHERE c.user_id = 'UUID_TARGET_USER';
```

---

## 4. Row Level Security (RLS) Policies

Untuk keamanan, Supabase menerapkan RLS:

1.  **Public Read**:
    - Tabel `products`, `prices`, `product_images` bisa dibaca (`SELECT`) oleh siapa saja (anon/public).
2.  **Authenticated Write (Admin)**:
    - Hanya user dengan role admin (atau logic tertentu) yang bisa `INSERT/UPDATE/DELETE` di tabel produk.
3.  **User Data Privacy**:
    - Tabel `cart`: User hanya bisa melihat (`SELECT`) dan memodifikasi (`INSERT/UPDATE/DELETE`) baris di mana `user_id` cocok dengan ID mereka sendiri.
    - Policy: `auth.uid() = user_id`.

---

_Dokumen ini dibuat berdasarkan implementasi kode `productService.js` dan `cartService.js` per tanggal 14 Desember 2025._
